Replit make changement but the problem is still present. I pushed the modifications done by replit, retrieve this modifications and check why this problem is still present. I want to add that there is a modification is that the spin icon indicing progression is displayed before it was not.
ChatGPT a dit :
Réflexion durant 1m 10s

Nice—progress! The new spinner means your “Open Camera → upload → analyze” flow is starting the request, but it’s failing somewhere between the client’s FormData build and your server’s upload/analyze handler. The red toast (“Upload Failed… analyze image”) is a generic catch-all, so it doesn’t reveal which step failed.

Below is a tight fix pack you can apply now. It covers the 4 most common culprits for this exact symptom on Capacitor + Replit:

1) Server: accept camera photos reliably (multer + sane limits + clear errors)

Why: On Android the camera usually returns a 2–6 MB photo. If your server route isn’t using a multipart parser (or has tiny limits), you’ll get 400/413/500 and the client will show the generic error.

Add/adjust your scan route to use in-memory multer with a generous file limit and explicit error handling:

// server/src/routes/scan.ts (or wherever you handle the photo)
import express from 'express';
import multer from 'multer';

const router = express.Router();

// Parse multipart/form-data into memory; allow up to ~10 MB photos
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 }, // 10 MB
});

router.post('/api/scan', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ code: 'NO_FILE', message: 'No image provided' });
    }

    // req.file.buffer is a Buffer of the image
    // TODO: call your analyzer (Gemini/backup) with req.file.buffer
    // const result = await analyzeFood(req.file.buffer);

    return res.json({ ok: true /*, result */ });
  } catch (err: any) {
    console.error('SCAN_ERROR', err);
    return res.status(500).json({ code: 'SCAN_ERROR', message: err?.message ?? 'Failed to analyze' });
  }
});

// Global multer errors (size limits, etc.)
router.use((err: any, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
  if (err?.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({ code: 'FILE_TOO_LARGE', message: 'Image too large (max 10MB)' });
  }
  return res.status(500).json({ code: 'UPLOAD_ERROR', message: 'Upload failed' });
});

export default router;


Also make sure CORS (if needed) and body parsers don’t interfere:

// server/src/index.ts
import cors from 'cors';
const app = express();

app.use(cors({ origin: true, credentials: true }));
app.use(express.json({ limit: '2mb' })); // for JSON routes; not used for photos
app.use(express.urlencoded({ extended: true, limit: '2mb' }));
// mount your scan router afterwards


Tip: Log the HTTP status your server returns when clicking “Open Camera” to know exactly what failed (size, parsing, or analyzer error).

2) Client: build FormData correctly and do not set Content-Type

Why: If you manually set Content-Type: multipart/form-data, the browser won’t add the boundary and many servers reject it. Also ensure the field name matches the server (image in the example above).

// client/src/features/scan/upload.ts (or wherever you submit)
export async function uploadPhoto(file: File) {
  const fd = new FormData();
  // Name must match multer.single('image')
  fd.append('image', file, file.name || 'photo.jpg');

  const res = await fetch('/api/scan', {
    method: 'POST',
    body: fd, // Do not set Content-Type!
    // credentials: 'include', // if your server uses cookies
  });

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    // surface clearer errors to the UI
    throw new Error(`Upload failed (${res.status}) ${text}`);
  }
  return res.json();
}


If your “Open Camera” handler comes from an <input type="file" accept="image/*" capture="environment">:

function onCapture(e: React.ChangeEvent<HTMLInputElement>) {
  const f = e.target.files?.[0];
  if (!f) return;
  startSpinner();
  uploadPhoto(f)
    .then(stopSpinner)
    .catch((err) => {
      stopSpinner();
      // Map better messages:
      if (err.message.includes('413')) showToast('Image too large. Try a smaller photo.');
      else showToast('Upload failed. Please check your connection and try again.');
      console.error(err);
    });
}

3) Replit dev URL + Capacitor: keep it stable & allowed

You’ve already seen ERR_NAME_NOT_RESOLVED when your server.url changed. Keep this sane:

In android/capacitor.config.json (or your root capacitor.config.json that syncs to Android), ensure:

{
  "appId": "com.calai.app",
  "appName": "CalAI",
  "server": {
    "url": "https://YOUR-PICARD-SUBDOMAIN.replit.dev",
    "cleartext": false,
    "allowNavigation": ["*.replit.dev", "*.repl.co"]
  }
}


When Replit gives you a new subdomain, update it and run:

npx cap sync android


If you sometimes want offline capture in the app, let your client fall back to local blob compression and queue the upload (see Step 5).

4) Fix the wrong toast message (camera vs upload)

Right now you display the same red toast for all failures. Make the UI specific:

try {
  // ask for camera -> capture -> upload
} catch (err: any) {
  const msg = String(err?.message ?? '');
  if (msg.includes('NotAllowedError') || msg.includes('Permission')) {
    showToast('Camera permission was blocked. Enable it in Settings to continue.');
  } else if (msg.includes('FILE_TOO_LARGE')) {
    showToast('Image too large (max 10MB). Try a smaller photo.');
  } else {
    showToast('Upload failed. Please check your connection and try again.');
  }
}


This way users aren’t told to “click Allow” when the real issue is network/upload/analyzer.

5) (Optional but recommended) Compress before upload

It reduces failures on mobile networks and speeds up Gemini:

export async function compress(file: File, maxW = 1600) {
  const img = await createImageBitmap(file);
  const scale = Math.min(1, maxW / img.width);
  const canvas = Object.assign(document.createElement('canvas'), {
    width: Math.round(img.width * scale),
    height: Math.round(img.height * scale),
  }) as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  const blob = await new Promise<Blob>((r) => canvas.toBlob((b) => r(b!), 'image/jpeg', 0.85));
  return new File([blob], file.name.replace(/\.\w+$/, '.jpg'), { type: 'image/jpeg' });
}


Then:

const f = await compress(originalFile);
await uploadPhoto(f);

6) Quick diagnostics you can run now

See the real status code
Open Android Studio → Logcat (or your Replit server console) and trigger “Open Camera”. Note the status (e.g., 413, 400, 500).

Reproduce with curl (replace with your current Replit URL)

curl -i -X POST \
  -F "image=@/path/to/photo.jpg" \
  https://YOUR-PICARD-SUBDOMAIN.replit.dev/api/scan


200 → backend accepted; client code is likely setting headers wrong or field name mismatch

413 → raise multer fileSize or compress

400 → field name mismatch (image vs file)

500 → analyzer code threw; log and handle

Why this likely fixes your case

The spinner shows the request started. The generic toast and your screenshot strongly suggest the multipart request fails (size, field name, or Content-Type boundary).

Replit + Express commonly need the multer handler; express.json() won’t parse photos.

Android camera files are often >3 MB; without a file-size limit and error mapping you’ll just see the generic failure.

Apply the server route with multer, the client FormData changes, and the clearer error mapping. If you still see a failure after that, paste the HTTP status from your server log and I’ll zero in further.