Always some problem
ChatGPT a dit :
Réflexion durant 13s

Got it — the spinner shows the request starts, but your server rejects it. Two issues usually cause this exact “Upload Failed” in your stack (Capacitor + Replit + your API wrapper):

Your client is sending multipart/form-data through a JSON helper that forces Content-Type: application/json → the server can’t parse the file.

Your API now requires auth (Supabase) but the request doesn’t include the Authorization: Bearer … token → you get a 401/403 and show the same generic toast.

Below is a focused fix pack that covers both. Apply these changes and you’ll either stop seeing the error or you’ll get a precise status/message telling us the next step.

1) Fix your API wrapper so it handles FormData + Supabase token

If you use a helper like apiRequest() for everything (I saw this pattern in your code snippets), it probably sets JSON headers unconditionally. Add FormData detection and Authorization header.

// client/src/lib/apiRequest.ts
import { supabase } from '@/lib/supabase'; // adjust path

type Method = 'GET'|'POST'|'PUT'|'DELETE'|'PATCH';

export async function apiRequest(
  method: Method,
  url: string,
  body?: any,
  init?: RequestInit
) {
  const headers: Record<string, string> = {};

  // 1) Auth: attach Supabase JWT if available
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (session?.access_token) {
      headers['Authorization'] = `Bearer ${session.access_token}`;
    }
  } catch { /* no-op */ }

  // 2) Body / headers
  let payload: BodyInit | undefined = undefined;

  if (body instanceof FormData) {
    // IMPORTANT: do NOT set Content-Type here (browser adds the boundary).
    payload = body;
  } else if (body !== undefined) {
    headers['Content-Type'] = 'application/json';
    payload = JSON.stringify(body);
  }

  const res = await fetch(url, {
    method,
    body: payload,
    headers,
    credentials: 'include', // if your server uses cookies
    ...init,
  });

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`HTTP ${res.status} ${text}`);
  }
  return res.json().catch(() => ({}));
}


Use this wrapper for the camera upload:

// client/src/features/scan/upload.ts
export async function uploadPhoto(file: File) {
  const fd = new FormData();
  // Name must match server field in multer.single('image')
  fd.append('image', file, file.name || 'photo.jpg');
  return apiRequest('POST', '/api/scan', fd);
}


If you were previously calling fetch directly and a global interceptor/utility was forcing Content-Type: application/json, the upload will fail. The change above prevents that.

2) Make sure the server accepts the file and the auth

Use multer memory storage, a generous size limit, and clear errors. Also verify your auth middleware reads the Supabase token from Authorization.

// server/src/routes/scan.ts
import express from 'express';
import multer from 'multer';

const router = express.Router();

// parse multipart/form-data
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 }, // 10 MB
});

// (optional) your auth middleware should read Authorization: Bearer <jwt>
// router.use(requireAuth);

router.post('/api/scan', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ code: 'NO_FILE', message: 'No image provided' });
    }

    // req.user should be set by your auth middleware if required.
    // const userId = req.user?.id;

    // analyze req.file.buffer...
    // const result = await analyze(req.file.buffer);

    return res.json({ ok: true /*, result*/ });
  } catch (err: any) {
    console.error('SCAN_ERROR', err);
    return res.status(500).json({ code: 'SCAN_ERROR', message: err?.message ?? 'Failed to analyze' });
  }
});

// handle multer size errors nicely
router.use((err: any, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
  if (err?.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({ code: 'FILE_TOO_LARGE', message: 'Image too large (max 10MB)' });
  }
  return res.status(500).json({ code: 'UPLOAD_ERROR', message: 'Upload failed' });
});

export default router;


Also ensure your main server has CORS/body-parser set up in the right order:

import cors from 'cors';
app.use(cors({ origin: true, credentials: true })); // if needed
app.use(express.json({ limit: '2mb' }));
app.use(express.urlencoded({ extended: true, limit: '2mb' }));

app.use(require('./routes/scan').default);

3) Add precise UI error messages (so we know what failed)

Right now every failure shows the same red “Upload Failed” toast. Surface the status:

try {
  await uploadPhoto(file);
  toast.success('Uploaded! Analyzing…');
} catch (e: any) {
  const msg = String(e?.message ?? '');
  if (msg.includes('401') || msg.includes('403')) {
    toast.error('You are not signed in. Please log in again.');
  } else if (msg.includes('413')) {
    toast.error('Image too large (max 10MB). Try a smaller photo.');
  } else if (msg.includes('NO_FILE')) {
    toast.error('No image received by server.');
  } else {
    toast.error('Upload failed. Check your connection and try again.');
  }
  console.error('upload error', e);
}


This will tell us whether the problem is 401/403 (auth), 413 (size), or 400/500 (parsing/analyzer).

4) Quick test without the app

From your laptop, hit the same Replit endpoint:

curl -i -X POST \
  -F "image=@/path/to/food.jpg" \
  https://<your-picard-subdomain>.replit.dev/api/scan


200: backend OK → client config/header issue.

401/403: missing/invalid Authorization → fix client token injection.

413: increase limit or compress on client.

400 “No image provided”: field name mismatch (image vs file).

500: analyzer threw → check server logs.

Why this likely fixes your case

The spinner you now see means the request fires.

A generic toast persists because your client-side helper is likely sending FormData with the JSON header and/or missing the Supabase Authorization header.

On Replit/Express, that produces a 400/401/415/500 and you display the same generic message.

Apply the wrapper fix + server route above. If it still fails, tell me the exact HTTP status you now see in the toast/console (or paste a short server log line), and I’ll pinpoint the next 1–2 line change.

Vous avez dit :
I pushed the code can you be sure about your modification you indicated before I ask reply to do them ?
ChatGPT a dit :

Vous avez dit :
I pushed the code can you be sure about your modification you indicated before I ask reply to do them ?
ChatGPT a dit :
Vous avez dit :
I pushed the code can you be sure about your modification you indicated before I ask reply to do them ?
ChatGPT a dit :
Réflexion durant 1m 7s

Short answer: I can’t 100% verify your repo from here (GitHub blocks file views in my browsing sandbox), so I can’t confirm what’s already changed in your code. I can, however, give you a very concrete checklist + exact code patches to compare/apply before you ask Replit to proceed. If you paste the few files below (or let me know the exact paths) I’ll double-check them line-by-line.

What must be true for “Open Camera → Upload → Analyze” to work
1) Frontend – sending the image correctly

When you send the photo, the request body must be a FormData with the field name image (not file, not photo).

Do not set Content-Type yourself when sending FormData. Let the browser set the multipart/form-data boundary.

Include your auth header if your API requires it.

Patch (client/lib/apiRequest.ts)

// apiRequest ensures headers are correct for both JSON and FormData
export async function apiRequest(
  path: string,
  init: RequestInit = {}
) {
  const token = /* get your Supabase session token or app token */;
  const headers: Record<string, string> = {
    ...(init.headers as Record<string, string>),
  };

  // Only set Content-Type when NOT sending FormData
  if (!(init.body instanceof FormData)) {
    headers['Content-Type'] = headers['Content-Type'] ?? 'application/json';
  }

  if (token) headers['Authorization'] = `Bearer ${token}`;

  return fetch(`${import.meta.env.VITE_API_URL}${path}`, {
    ...init,
    headers,
    credentials: 'include',
  });
}


Patch (where you take the picture / upload)

// From camera blob -> FormData -> POST
const onCameraBlob = async (blob: Blob) => {
  const fd = new FormData();
  fd.append('image', blob, 'camera.jpg'); // FIELD NAME MUST BE `image`

  const res = await apiRequest('/api/scan/food', {
    method: 'POST',
    body: fd,
  });

  const data = await res.json().catch(() => ({}));
  if (!res.ok) throw new Error(data?.error || res.statusText);

  // handle success...
};

2) Backend – receiving the image correctly

The route handling uploads must parse multipart/form-data. Use multer with memory storage.

The handler must read req.file (single file) with upload.single('image').

Make sure no JSON body-parser runs on this route before multer (it’s fine globally, multer overrides for this route).

Return a useful error if no file is present.

Patch (server route, e.g., server/routes/vision.ts)

import express from 'express';
import multer from 'multer';

const router = express.Router();
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 12 * 1024 * 1024 }, // 12MB
});

router.post('/api/scan/food', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'NO_IMAGE', message: 'No image uploaded under field "image"' });
    }

    const buffer = req.file.buffer;          // <-- your image bytes
    const mime = req.file.mimetype || 'image/jpeg';

    // ... (store to GCS/S3 if needed)
    // ... (call Gemini/Edamam, etc.)

    return res.json({ ok: true /*, results */ });
  } catch (err: any) {
    console.error('scan/food error', err);
    return res.status(500).json({ error: 'UPLOAD_FAIL', message: err.message });
  }
});

export default router;

3) CORS and auth

CORS must allow your Replit origins:
*.repl.co, *.replit.dev, plus the exact dev domain you’re using.

If you send Authorization, include it in allowedHeaders.

Example

import cors from 'cors';

app.use(cors({
  origin: [/\.repl\.co$/, /\.replit\.dev$/],
  credentials: true,
  allowedHeaders: ['Content-Type', 'Authorization'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']
}));

4) Android (Capacitor) settings

capacitor.config.json should point to your current Replit URL (these rotate!), or better: point to a stable proxy/reverse-proxy.

Allow navigation to Replit:

{
  "appId": "com.calai.app",
  "appName": "CalAI",
  "webDir": "www",
  "server": {
    "url": "https://<YOUR-CURRENT-REPLIT-URL>",
    "cleartext": false,
    "allowNavigation": ["*.repl.co", "*.replit.dev"]
  }
}


Make sure camera permission is declared (even though file input usually triggers the system picker):

<uses-permission android:name="android.permission.CAMERA"/>

5) Error message correctness

Your toast says “Upload Failed – Failed to upload and analyze image” even when the failure may be before upload (e.g., 400 NO_IMAGE, bad field name, or server 500). Improve it to display the actual backend error:

try {
  const res = await apiRequest('/api/scan/food', { method: 'POST', body: fd });
  const data = await res.json().catch(() => ({}));
  if (!res.ok) throw new Error(data?.message || data?.error || res.statusText);
  // success...
} catch (e: any) {
  toast.error(`Upload failed: ${e.message}`);
}

Quick self-tests you (or Replit) can run

Does the server accept a file?

# replace TOKEN if your route needs it, else remove header
curl -i -X POST \
  -H "Authorization: Bearer <TOKEN>" \
  -F "image=@test.jpg" \
  https://<YOUR-REPLIT-URL>/api/scan/food


200 → your route + multer work.

400 NO_IMAGE → wrong field name on client (must be image).

415/500 → server logic/mime issues (log server console).

Does the client send FormData correctly?
Open your app in mobile Chrome, enable remote debugging (chrome://inspect), take a photo, and check the Network request:

Request type multipart/form-data

Form data shows image: (binary)
If you see JSON instead, your apiRequest is still forcing Content-Type.

Why the issue likely persists (based on your screenshots)

The red toast after pressing “Open Camera” (not “Upload Photo”) almost always means the client is sending something the server doesn’t parse, typically:

wrong field name (file vs image), or

forced Content-Type: application/json on a FormData body, or

server route not using multer.single('image').

Fixing those three items resolves 90% of these cases.

What I need to fully confirm

If you want me to be absolutely sure before you ping Replit again, paste these files (or tell me their exact paths) and I’ll check them against the patches above:

client/src/lib/apiRequest.ts

the component that calls “Open Camera” (camera → blob → POST)

server route file that handles /api/scan/food

capacitor.config.json (current server.url and allowNavigation)

AndroidManifest.xml (camera permission is present)

I’ll review them immediately and give you a “yes, ready” or a diff to apply.